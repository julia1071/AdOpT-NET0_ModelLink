from pathlib import Path

import numpy as np
from adopt_net0.utilities import get_set_t
import config_model_linking as cfg


def get_results_cluster_technology_output_dict(adopt_hub):
    """
    Extracts total output values for specified technologies from HDF5 result files generated by the cluster model.
    Supports multiple outputs per technology using custom alias keys.

    Args:
        adopt_hub: The model object with the results of the cluster.

    Returns:
        dict: Dictionary with keys of the form (location, interval, tech_alias) and values as total output floats.
    """
    print("Extracting technology outputs from cluster model")

    # Include "_existing" variants for each tech alias
    tech_output_map = {}
    for alias, (actual_tech, output_var) in cfg.base_tech_output_map.items():
        tech_output_map[alias] = (actual_tech, output_var)
        tech_output_map[f"{alias}_existing"] = (f"{actual_tech}_existing", output_var)

    tech_ops_map = cfg.link_ops_techs.union({f"{alias}_existing" for alias in cfg.link_ops_techs})

    # Define scaling factor if using fast_run
    factor_fast_run = 876 if cfg.fast_run else 1
    resolution = 'full' if cfg.fast_run else 'clustered'

    tech_output_dict = {
        "AnnualOutput": {},
        "Operation": {}
    }

    for interval in cfg.intervals:
        interval_block = adopt_hub[interval].model[resolution].periods[interval]
        set_t = get_set_t(adopt_hub[interval].data.model_config, interval_block)
        for alias, (actual_tech_name, output_var_name) in tech_output_map.items():
            if actual_tech_name in interval_block.node_blocks[cfg.location].tech_blocks_active:
                tech_block = interval_block.node_blocks[cfg.location].tech_blocks_active[actual_tech_name]
                if '_input' in alias:
                    annual_prod = sum(tech_block.var_input_tot[t, output_var_name].value for t in set_t)

                elif '_olefin' in alias:
                    if '_existing' not in actual_tech_name:
                        annual_prod_eSMR = sum(tech_block.var_output_tot[t, output_var_name].value for t in set_t)
                        tech_block_WGS = interval_block.node_blocks[cfg.location].tech_blocks_active["WGS_m"]
                        annual_cons_WGS = sum(tech_block_WGS.var_input_tot[t, "syngas_r"].value for t in set_t)

                        if "ElectricSMR_m_existing" in interval_block.node_blocks[cfg.location].tech_blocks_active:
                            tech_block_eSMR_ex = interval_block.node_blocks[cfg.location].tech_blocks_active["ElectricSMR_m_existing"]
                            annual_prod_eSMR_ex = sum(tech_block_eSMR_ex.var_output_tot[t, "syngas_r"].value for t in set_t)
                        else:
                            annual_prod_eSMR_ex = 0

                        if "WGS_m_existing" in interval_block.node_blocks[cfg.location].tech_blocks_active:
                            tech_block_WGS_ex = interval_block.node_blocks[cfg.location].tech_blocks_active["WGS_m_existing"]
                            annual_cons_WGS_ex = sum(tech_block_WGS_ex.var_input_tot[t, "syngas_r"].value for t in set_t)
                        else:
                            annual_cons_WGS_ex = 0


                        annual_prod = (annual_prod_eSMR + annual_prod_eSMR_ex) - (annual_cons_WGS + annual_cons_WGS_ex)

                    else:
                        annual_prod = 0

                else:
                    annual_prod = sum(tech_block.var_output_tot[t, output_var_name].value for t in set_t)

                if annual_prod > 1e-5:
                    tech_output_dict["AnnualOutput"][(cfg.location, interval, alias)] = annual_prod * factor_fast_run
                    print(f"ℹ️ Output of {alias} in {interval} at {cfg.location}: {annual_prod * factor_fast_run}")

                if cfg.linking_operation and actual_tech_name in tech_ops_map:
                    total_cons = sum(tech_block.var_input_tot[t, "electricity"].value for t in set_t)
                    operation_tech = np.array([tech_block.var_input_tot[t, "electricity"].value for t in set_t])
                    if total_cons > 0:

                        capacity_factor = operation_tech / total_cons
                        capacity_factor[capacity_factor < 1e-5] = 0

                        if cfg.fast_run:
                            repeats = 8760 // len(capacity_factor)
                            capacity_factor = np.tile(capacity_factor, repeats)
                            capacity_factor = capacity_factor / factor_fast_run

                        tech_output_dict["Operation"][(cfg.location, interval, alias)] = capacity_factor
                    else:
                        tech_output_dict["Operation"][(cfg.location, interval, alias)] = None

            elif actual_tech_name == "biogas_import":
                interval_block = adopt_hub[interval].model[resolution].periods[interval]
                set_t = get_set_t(adopt_hub[interval].data.model_config, interval_block)
                node_block = interval_block.node_blocks[cfg.location]

                biogas_val = sum(node_block.var_import_flow[t, output_var_name].value for t in set_t) if any(
                    car == output_var_name for (_, car) in node_block.var_import_flow.index_set()) else 0

                if biogas_val > 1e-5:
                    tech_output_dict["AnnualOutput"][(cfg.location, interval, alias)] = biogas_val * factor_fast_run
                    print(f"ℹ️ Output of {alias} in {interval} at {cfg.location}: {biogas_val * factor_fast_run}")


    return tech_output_dict

