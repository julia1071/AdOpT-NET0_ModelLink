import pandas as pd
from pathlib import Path

import config_model_linking as cfg
from conversion_factors import conversion_factor_IESA_to_cluster
from calculate_avg_bio_methane_cost import calculate_avg_bio_methane_cost

def get_results_IESA_dict(results_file_path):
    """
    Extracts data from multiple sheets of an Excel file generated by IESA-Opt,
    using specified filters and headers for different intervals and sheets.

    Args:
        results_file_path (str or Path): Path to Excel file

    Returns:
        dict: Nested dict with keys 'results_<interval>_<sheet>' containing lists of filtered entries
    """
    print("Start extracting data from IESA-Opt")

    # Validate input lengths
    if len({len(cfg.list_sheets), len(cfg.nrows), len(cfg.headers), len(cfg.filters)}) != 1:
        raise ValueError("All input lists (sheets, nrows, headers, filters) must have the same length.")

    results_dict = {}

    # Iterate over sheets and associated filter definitions
    for sheet_name, num_rows, header, sheet_filters in zip(cfg.list_sheets, cfg.nrows, cfg.headers, cfg.filters):
        df = pd.read_excel(results_file_path, sheet_name=sheet_name, nrows=num_rows, header=0)

        # Validate header presence once
        if isinstance(header, str):
            if header not in df.columns:
                raise ValueError(f"Header '{header}' not found in sheet '{sheet_name}'.")
        elif isinstance(header, tuple):
            missing = [h for h in header if h not in df.columns]
            if missing:
                raise ValueError(f"Headers {missing} not found in sheet '{sheet_name}'.")

        # Process each interval
        for interval in cfg.intervals:
            key = f"results_{interval}_{sheet_name}"
            results_dict.setdefault(key, [])

            # Filter rows based on provided filters
            for filter_value in sheet_filters:
                filter_entry = {}

                if isinstance(header, str):
                    condition = df[header] == filter_value
                    filter_entry[header] = filter_value
                elif isinstance(header, tuple) and isinstance(filter_value, tuple):
                    if len(header) != len(filter_value):
                        raise ValueError(f"Mismatch between header and filter tuple lengths in sheet '{sheet_name}'.")
                    condition = pd.Series(True, index=df.index)
                    for h, f in zip(header, filter_value):
                        condition &= df[h] == f
                        filter_entry[h] = f
                else:
                    raise ValueError(f"Header/filter mismatch in sheet '{sheet_name}': {header}, {filter_value}")

                matched_rows = df[condition]

                if matched_rows.empty:
                    raise ValueError(
                        f"No match found for filter {filter_entry} in sheet '{sheet_name}' for year '{interval}'."
                    )

                try:
                    extracted_value = float(matched_rows[interval].values[0])
                except KeyError:
                    raise ValueError(
                        f"Year column '{interval}' not found in sheet '{sheet_name}'.\n"
                        f"Available columns: {list(df.columns)}"
                    )

                filter_entry["value"] = extracted_value
                results_dict[key].append(filter_entry)

    print("The raw results dictionary from IESA-Opt is created")
    return results_dict


def get_value_IESA_multiple(dict, interval, sheet, **filters):
    key = f"results_{interval}_{sheet}"
    entries = dict.get(key, [])

    for entry in entries:
        if all(entry.get(k) == v for k, v in filters.items()):
            return entry['value']

    raise ValueError(f"No value found for {interval}, {sheet}, filters: {filters}")


def convert_IESA_to_cluster_dict(results_IESA_dict, results_path_IESA):
    cluster_results = {}

    for interval in cfg.intervals:
        interval_data = {}

        # --- Linking energy prices ---
        if cfg.linking_energy_prices:
            for sheet, activity_list in zip(cfg.list_sheets, cfg.filters):
                for activity in activity_list:
                    conv = conversion_factor_IESA_to_cluster(sheet, activity)
                    value = get_value_IESA_multiple(results_IESA_dict, interval, sheet, Activity=activity)
                    carrier = cfg.cluster_carrier_names[activity]
                    interval_data[carrier] = conv * value

            # Special case: Bio Methane
            bio_cost = calculate_avg_bio_methane_cost(results_path_IESA, interval)
            conv_bio = conversion_factor_IESA_to_cluster('EnergyCosts', 'methane_bio')
            interval_data['methane_bio'] = conv_bio * bio_cost if bio_cost is not None else None

        # # --- Linking MPW availability ---
        # elif cfg.linking_MPW:
        #     # Example logic — adjust as needed for your actual MPW workflow
        #     mpw_data = get_mpw_availability(results_IESA_dict, interval)
        #     for mpw_type, value in mpw_data.items():
        #         conv = conversion_factor_IESA_to_cluster('MPWAvailability', mpw_type)
        #         interval_data[mpw_type] = conv * value

        cluster_results[interval] = interval_data

    return {cfg.location: cluster_results}


# def convert_IESA_to_cluster_dict(results_IESA_dict, results_path_IESA):
#     converted_results = {cfg.location: {}}
#
#     for interval in cfg.intervals:
#         sheet_dict = {}
#         for sheet, activity_list in zip(cfg.list_sheets, cfg.filters):
#
#
#             if cfg.linking_energy_prices:
#
#                 for activity in activity_list:
#                     conv = conversion_factor_IESA_to_cluster(sheet, activity)
#                     value = get_value_IESA_multiple(results_IESA_dict, interval, sheet, Activity=activity)
#                     sheet_dict[cfg.cluster_carrier_names[activity]] = conv * value
#
#         # Special case: Bio Methane
#         if cfg.linking_energy_prices:
#             avg_bio_methane_cost = calculate_avg_bio_methane_cost(results_path_IESA, interval)
#
#             if avg_bio_methane_cost is not None:
#                 conv = conversion_factor_IESA_to_cluster('EnergyCost', 'methane_bio')
#                 sheet_dict['methane_bio'] = conv * avg_bio_methane_cost
#             else:
#                 sheet_dict['methane_bio'] = None
#
#         converted_results[cfg.location][interval] = sheet_dict
#
#     return converted_results


            # elif linking_MPW:
            #     # --- Mixed Plastic Waste (MPW) ---
            #     sheet_key = f"results_{interval}_SupplyDemand"
            #     total_mpw_supply = 0.0
            #
            #     for entry in results_IESA_dict.get(sheet_key, []):
            #         if entry.get("Activity") == "Mixed Plastic Waste" and entry.get("Type") == "supply":
            #             tech_id = entry.get("Tech_ID")
            #             value = entry.get("value")
            #
            #             if value is None:
            #                 print(f"⚠️ No value found for Tech_ID '{tech_id}' in interval {interval}")
            #                 continue
            #
            #             try:
            #                 factor = conversion_factor_IESA_to_cluster(
            #                     "SupplyDemand", tech_id, ppi_file_path, baseyear_cluster, baseyear_IESA
            #                 )
            #                 total_mpw_supply += factor * value
            #             except Exception as e:
            #                 print(f"⚠️ Skipping {tech_id} due to error: {e}")
            #
            #     # Store the MPW import limit in cluster model input and PyPSA structure
            #     input_cluster[location][interval]['Import limit MPW'] = total_mpw_supply
            #     pyhub[interval].data.time_series['full'][
            #         interval, location, 'MPW', 'global', 'Import limit'
            #     ] = total_mpw_supply
            #
            #     print(f"The value that is inputted as import limit for MPW is {total_mpw_supply:.2f}")