
import h5py
import pandas as pd
from pathlib import Path
from adopt_net0 import extract_datasets_from_h5group

# result_folder = Path(r"U:\Data AdOpt-NET0\Model_Linking_simplified\Results\Zeeland\Results_model_linking_20250630_15_58\Iteration_1")
# intervals =['2030', '2040', '2050']
# location = "Zeeland"
# base_tech_output_map = {
#     "CrackerFurnace": ("CrackerFurnace", "olefins_output"),
#     "CrackerFurnace_Electric": ("CrackerFurnace_Electric", "olefins_output"),
#     "MTO": ("MTO", "ethylene_output"),
#     "PDH": ("PDH", "propylene_output"),
#     "MPW2methanol_input": ("MPW2methanol", "MPW_input"),
#     "MPW2methanol_output": ("MPW2methanol", "methanol_output"),
#     "SteamReformer": ("SteamReformer", "HBfeed_output"),
#     "AEC": ("AEC", "hydrogen_output"),
#     "ElectricSMR_m": ("ElectricSMR_m", "syngas_r_output"),
#     "CO2electrolysis": ("CO2electrolysis", "ethylene_output")
# }
#
# fast_run = False


def extract_technology_outputs(base_tech_output_map, result_folder, intervals, location, fast_run):
    """
    Extracts total output values for specified technologies from HDF5 result files generated by the cluster model.
    Supports multiple outputs per technology using custom alias keys.

    Args:
        base_tech_output_map (dict): Dictionary where each key is a custom alias (e.g., "MPW2methanol_input")
                                     and each value is a tuple (actual_tech_name_in_HDF5, output_variable_name).
        result_folder (Path): Path to the folder containing the optimization results and Summary.xlsx.
        intervals (list): List of year intervals to extract data for.
        location (str): Location name used in HDF5 column structure.
        fast_run (bool): If True, scales output values by a factor (default: 876 instead of 8760).

    Returns:
        dict: Dictionary with keys of the form (location, interval, tech_alias) and values as total output floats.
    """
    print("Extracting technology outputs from cluster model")

    summary_path = result_folder / "Summary.xlsx"
    try:
        summary_df = pd.read_excel(summary_path)
    except FileNotFoundError:
        raise FileNotFoundError(f"Missing summary: {summary_path}")

    # Include "_existing" variants for each tech alias
    tech_output_map = {}
    for alias, (actual_tech, output_var) in base_tech_output_map.items():
        tech_output_map[alias] = (actual_tech, output_var)
        tech_output_map[f"{alias}_existing"] = (f"{actual_tech}_existing", output_var)

    # Define scaling factor if using fast_run
    factor_fast_run = 876 if fast_run else 1

    tech_output_dict = {}

    for _, row in summary_df.iterrows():
        case = row["case"]
        if pd.isna(case):
            continue

        matched_interval = next((i for i in intervals if i in case), None)
        if matched_interval is None:
            continue

        h5_path = result_folder / row["time_stamp"] / "optimization_results.h5"
        if not h5_path.exists():
            print(f"Missing h5 file: {h5_path}")
            continue

        with h5py.File(h5_path, "r") as hdf_file:
            tec_operation = extract_datasets_from_h5group(hdf_file["operation/technology_operation"])
            # Filter incomplete time series
            tec_operation = {k: v for k, v in tec_operation.items() if len(v) >= 8670 / factor_fast_run}
            df_op = pd.DataFrame(tec_operation)

            if df_op.columns.nlevels > 2:
                for alias, (actual_tech_name, output_var_name) in tech_output_map.items():
                    col = (matched_interval, location, actual_tech_name, output_var_name)
                    if col in df_op.columns:
                        total_output = df_op[col].sum()
                        value = float(total_output * factor_fast_run)

                        if value > 0:
                            tech_output_dict[(location, matched_interval, alias)] = value
                        else:
                            print(f"ℹ️ Output of {alias} in {matched_interval} at {location}: 0.0")

    return tech_output_dict



# print(extract_technology_outputs(base_tech_output_map, result_folder,intervals, location, fast_run))