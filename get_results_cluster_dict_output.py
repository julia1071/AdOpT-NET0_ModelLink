
import h5py
import pandas as pd
from pathlib import Path
from adopt_net0 import extract_datasets_from_h5group

# result_folder = Path("U:\Data AdOpt-NET0\Model_Linking_simplified\Results\Zeeland\Results_model_linking_20250624_17_38\Iteration_1")
# intervals =['2030','2040','2050']
# location = "Zeeland"
# base_tech_output_map = {
#     "CrackerFurnace": "olefins_output",
#     "CrackerFurnace_Electric": "olefins_output",
#     "MTO": "ethylene_output",
#     "PDH": "propylene_output",
#     "MPW2methanol": "methanol_output",
#     "SteamReformer": "HBfeed_output",
#     "AEC": "hydrogen_output",
#     "ElectricSMR_m": "syngas_r_output",
#     "CO2electrolysis": "ethylene_output",
# }
#
# fast_run = 0


def extract_technology_outputs(base_tech_output_map, result_folder, intervals, location, fast_run):
    """
    Extracts total output values for selected technologies from HDF5 result files generated by the cluster model.

    Args:
        base_tech_output_map (dict): Mapping of base technology names to output variable names
        result_folder (Path): Path to the folder containing the optimization results and Summary.xlsx
        intervals (list): List of year intervals to match cases against
        location (str): The location identifier used in the result columns
        fast_run (bool): If True, scales output values by a fixed factor

    Returns:
        dict: Dictionary with keys (location, interval, technology) and values as total output floats
    """
    print("Extracting technology outputs from cluster model")

    # Path to the summary Excel file
    summary_path = result_folder / "Summary.xlsx"
    try:
        # Read the summary file containing the case info
        summary_df = pd.read_excel(summary_path)
    except FileNotFoundError:
        raise FileNotFoundError(f"Missing summary: {summary_path}")

    # Add "_existing" variants to the technology-output mapping
    tech_output_map = base_tech_output_map.copy()
    for tech, output in base_tech_output_map.items():
        tech_output_map[f"{tech}_existing"] = output

    tech_output_dict = {}

    # Iterate over each case listed in the summary
    for _, row in summary_df.iterrows():
        case = row["case"]
        if pd.isna(case):
            continue  # Skip empty rows

        # Match the case to a known interval
        matched_interval = next((i for i in intervals if i in case), None)
        if matched_interval is None:
            continue  # Skip cases without a valid year

        # Define the path to the HDF5 result file for this case
        h5_path = result_folder / row["time_stamp"] / "optimization_results.h5"
        if not h5_path.exists():
            print(f"Missing h5 file: {h5_path}")
            continue

        # Open the HDF5 file and extract technology operation data
        with h5py.File(h5_path, "r") as hdf_file:
            tec_operation = extract_datasets_from_h5group(hdf_file["operation/technology_operation"])
            # Filter out incomplete time series
            tec_operation = {k: v for k, v in tec_operation.items() if len(v) >= 8670}
            df_op = pd.DataFrame(tec_operation)

            # Process only if the dataframe has multi-level columns
            if df_op.columns.nlevels > 2:
                for tech in df_op.columns.levels[2]:  # Loop over technologies
                    output_col_name = None

                    # Find matching output variable for the technology
                    for prefix, output_name in tech_output_map.items():
                        if tech.startswith(prefix):
                            output_col_name = output_name
                            break
                    if not output_col_name:
                        continue  # Skip if no match found

                    # Construct the full column key (interval, location, tech, output)
                    col = (matched_interval, location, tech, output_col_name)
                    if col in df_op.columns:
                        total_output = df_op[col].sum()

                        # Optionally scale output if fast_run is enabled
                        if fast_run:
                            tech_output_dict[(location, matched_interval, tech)] = float(876 * total_output)
                        else:
                            tech_output_dict[(location, matched_interval, tech)] = float(total_output)

    return tech_output_dict


# print(extract_technology_outputs(base_tech_output_map, result_folder,intervals, location, fast_run))